Platform change specification grounded in existing architecture (entities in `src/practice/entities.py`, UseCase protocol, repository protocols, CLI DTOs). Design constraints: markdown+frontmatter storage with Pydantic entities through semantic waist; actionability-driven needs ("what are we able to improve?"); deny-all/allow-some security posture.

New entities: ObservationNeed (slug, owner_type, owner_ref, level type/instance, need, rationale, lifecycle_moment, served flag); RoutingAllowList with RoutingDestination (derived from engagement config — no new config surface); Observation (slug, source_inflection, need_refs, content, resolved destinations). Three destination classes: personal (always allowed, information-greedy), client/engagement-scoped (allow per engagement config, sibling projects cross-pollinate, engagement is trust boundary), commons (never — dark channel via #23).

New repository protocols: NeedsReader (type_level_needs by owner_type, instance_needs by owner_type+ref); ObservationWriter (persist to resolved destinations). Type-level needs in practice layer manifests, instance-level needs with destination instances.

New use cases: AggregateNeedsBrief (`practice observation-needs --client X --engagement Y`) — builds routing allow list from engagement config, gathers type+instance needs for eligible destinations, flags duplicates mechanically, synthesises brief; needs aggregation uses same allow list as routing. RouteObservations — resolves destinations from need_refs, verifies allow list, dispatches with fan-out. ReviewNeedsHygiene — surfaces four failure modes (staleness, duplication, supersession, unserved needs).

Needs lifecycle support: distributed declaration across each destination type's existing moments (client: research/planning/gatepoints/review/between; engagement: planning/execution/review; skillset: ns-design/ns-implement/rs-assess/rs-iterate/execution; personal: goal-setting/engagement/review; practice: planning/engagement/post-review). Authoring follows lifecycle phase — operator at planning, agent at gatepoints, both at review, skillset author at engineering.

Needs evolution: within-engagement (gatepoint N observations produce N+1 needs — system feeds itself, skills write new needs as side effect), cross-engagement (instance patterns promoted to type-level at review).

Skill changes: each inflection point gains observation step (request brief, apply to context, output observations, optionally write new needs). Review: comprehensive sweep, promotion moment. Gatepoint: lightweight side channel, self-feeding evolution. Negotiate: multi-scope. Pack-and-wrap: local only. Unchanged: client workspace structure, pack convention, engagement lifecycle, engagement configuration surface, integration surface, propose-negotiate-agree loop.
