Protocol: every observation destination declares its information needs. Analogous to actor-goals in pack manifests — destinations are actors with goals for sensory input. Guiding principle: needs are driven by the ability to act — "what are we able to improve?" Purpose of observations is to drive behaviour: continuous improvement, responsiveness, reinforcing positive habits, solving problems, mitigating risks. A well-formed need passes the test: "if the observer finds something, what improves?"

Inheritance model: type-level generic needs (all clients need stakeholder dynamics; all skillsets need what-worked/what-didn't) plus instance-level specific needs (a particular client's pecadilloes). CLI aggregation use case gathers relevant type+instance needs from all destinations, synthesises into a brief the skill consumes. Skill just asks for the brief — no knowledge of destinations, types, or inheritance required. Replaces the vague "bag of tricks" with concrete declared needs owned by destinations.

Storage format: markdown with structured YAML frontmatter and prose body. Repository implementation serialises/deserialises frontmatter into Pydantic entities (per src/practice/entities.py). Use cases operate in Python land through the semantic waist, not LLM land. Needs declarations live with their owners.
