Protocol: every observation destination declares its information needs. Analogous to actor-goals in pack manifests — destinations are actors with goals for sensory input. Guiding principle: needs are driven by the ability to act — "what are we able to improve?" A well-formed need passes the test: "if the observer finds something, what improves?"

Inheritance model: type-level generic needs plus instance-level specifics (pecadilloes). CLI aggregation use case gathers relevant type+instance needs, synthesises a brief the skill consumes.

Needs lifecycle: declaration is distributed across each destination type's existing lifecycle moments, not a single event. Client needs evolve at research, engagement planning, gatepoints, engagement review, and between engagements. Engagement needs at planning and during execution. Skillset needs at ns-design, ns-implement, rs-assess, rs-iterate, and during execution. Personal needs at goal setting, during engagement, and personal review. Practice needs at planning, during engagement, and post-review. Who authors depends on the lifecycle phase — operator at planning, agent at gatepoints, both at review, skillset author at engineering.

Needs evolution at two timescales: within-engagement (gatepoint N observations produce gatepoint N+1 needs — the system feeds itself) and across-engagements (instance patterns promoted to type-level at review — instance → pattern → type).

Needs hygiene: staleness (context changed), duplication (instance overlaps type or other instances), supersession (vague need replaced but not removed), unserved needs (either wrong need or blind spot — distinction matters). Review moments for hygiene align with declaration lifecycle. Aggregation use case can flag duplicates mechanically.

Storage: markdown+frontmatter, Pydantic entities through semantic waist. Needs declarations live with their owners.
