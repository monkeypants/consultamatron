Worked example validated the pattern against a fictional gatepoint scenario, then deepened the needs protocol with lifecycle, evolution, and hygiene models.

**Guiding principle.** Needs are driven by actionability — "what are we able to improve?" Well-formed need test: if the observer finds something, what improves?

**Storage format.** Markdown+frontmatter with Pydantic entities in `src/practice/entities.py`, repository serialisation through the semantic waist. Use cases in Python land, not LLM land.

**Sibling cross-pollination.** Engagement is the trust boundary, not the project. All projects within an engagement share a confidentiality context and can receive each other's observations.

**Needs lifecycle.** Distributed across existing activities — research, planning, gatepoints, review, skillset engineering. No new activities invented. Who writes depends on lifecycle phase: operator at planning, agent at gatepoints, both at review.

**Needs evolution.** Two timescales: within-engagement self-feeding (gatepoint N observations produce gatepoint N+1 needs) and cross-engagement promotion (instance → pattern → type, review is the promotion moment).

**Needs hygiene.** Four failure modes: staleness, duplication, supersession, unserved needs. Unserved needs require diagnosis — wrong need (prune) or blind spot (investigate). Hygiene review piggybacks on declaration lifecycle moments.
