Design specification for needs-driven observation routing. Four-stage pattern: inflection point (transient rich context) → observation needs brief (CLI-aggregated from destination declarations) → observations (high-freedom judgment applying brief to context) → routing (mechanical dispatch to need-identified destinations). Classification collapses — observations made in response to declared needs already carry their destination.

Seven accumulator items. General pattern: the four-stage flow and key architectural insights. Inflection point taxonomy: four types — engagement review (comprehensive), gatepoint (opportunistic), negotiate loop (multi-scope), pack-and-wrap (local only); three cross-context, one local. Observation needs protocol: destinations declare information needs driven by "what are we able to improve?"; type-level inheritance plus instance-level extension; needs lifecycle distributed across each destination type's existing lifecycle moments (research, planning, gatepoints, review, skillset engineering); within-engagement feedback loop (observations produce future needs) and cross-engagement promotion (instance → pattern → type); needs hygiene (staleness, duplication, supersession, unserved); storage as markdown+frontmatter with Pydantic entities through semantic waist. Observation/routing split: observation is high-freedom (applies brief to context), routing is low-freedom (dispatches to declared destinations); needs brief decouples them. Routing security model: deny-all/allow-some — routing is information transfer, ineligible destinations are data leaks; three classes: personal/ (greedy, always allowed), engagement-scoped (allow per engagement config, sibling projects cross-pollinate), commons/ (dark channel only via #23). Software changes: platform specification grounded in existing architecture — ObservationNeed/RoutingAllowList/Observation entities, NeedsReader/ObservationWriter repository protocols, AggregateNeedsBrief/RouteObservations/ReviewNeedsHygiene use cases; needs lifecycle support (distributed declaration), evolution support (two timescales), per-inflection-point skill changes; additive to existing platform, no new configuration surface. Worked example: end-to-end trace through a fictional engagement gatepoint validating all four stages.

Iteration 2 complete (stacked). History: iteration-2 (worked example, lifecycle, evolution, hygiene), iteration-1 (extraction, needs-driven refinement, security model), iteration-0 (original pattern discovery, jedi council, operator refinements).
