Design specification for needs-driven observation routing. Four-stage pattern: inflection point (transient rich context) → observation needs brief (CLI-aggregated from destination declarations) → observations (high-freedom judgment applying brief to context) → routing (mechanical dispatch to need-identified destinations). Classification collapses — observations made in response to declared needs already carry their destination.

Six accumulator items. General pattern: the four-stage flow and key architectural insights. Inflection point taxonomy: four types — engagement review (comprehensive), gatepoint (opportunistic), negotiate loop (multi-scope), pack-and-wrap (local only); three cross-context, one local. Observation needs protocol: destinations declare information needs with type-level inheritance and instance-level extension; CLI aggregation use case synthesises a brief the skill consumes; replaces the earlier "bag of tricks" concept. Observation/routing split: observation is high-freedom (applies brief to context), routing is low-freedom (dispatches to declared destinations); needs brief decouples them. Routing security model: deny-all/allow-some — routing is information transfer, ineligible destinations are data leaks; three classes: personal/ (greedy, always allowed), engagement-scoped (allow per engagement config), commons/ (dark channel only via #23, no direct routing). Software changes: needs protocol, CLI aggregation command, per-inflection-point skill changes, routing infrastructure; additive to existing platform.

Iteration 1 in progress. Stacked history in `_history/iteration-0/` (jedi council deliberation, operator refinements, original five-stage observe-classify-route pattern that evolved into the current needs-driven model).
