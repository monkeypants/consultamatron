---
source_hash: sha256:cdb2af997b5965114767bb67eabf13db0fa689f211bbff5d527dbc2e48da6cb9
---
A knowledge protocol emerges when a practice-layer use case processes typed pack items structurally. Protocol = type (frontmatter value) + contract (structural expectations) + use case (code that consumes items). Without a use case, items are reference material with a type label.

Four domain-generic protocols: pantheon (contribution + invocation trigger, jedi council selects luminaries), patterns (problem + solution + application trigger), principles (statement + provenance + application trigger), anti-patterns (surface appeal + damage + diagnostic trigger). Same protocols across any consulting domain with different content.

Three-layer architecture: convention (PackItem: name, type — storage and compression), use case (domain contracts — selection, analysis, synthesis), adapter (markdown with frontmatter — reading files). New protocols added at the use case layer; convention layer never changes (OCP vertical).

Promotion criterion: does `src/practice/` contain a use case that matches on this type? Build protocols when a recurring use case exists, the contract is concrete, and items already exist. Do not build speculatively.
